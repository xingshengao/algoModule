* 如果一个构造方法都没写, JVM虚拟机会默认给一个空参构造方法

* 构造方法至少写两个, 一个是无参构造, 一个是全参构造

* 标准 java类,每个私有成员函数都需要有set和get方法

* 插件PTG 直接生成标准javaBean类

* `this`的作用区分局部变量和成员变量, 本质代表方法调用者的地址值

* 成员变量: 类中方法外的变量, 成员变量: 方法内的变量

## `StringBuilder`

`append()`可以添加基本类型
`reverse()`
`length()`
`toString()`
`print()`
## `StringJoiner`
`StringJoiner sj = new StringJoiner("---");` 以---分割
`StringJoiner sj = new StringJoiner(", ", "[", "]");`间隔开始结束
`add()`
## `ArrayList`
`add()`
`remove()`
`change()`
## `static`静态变量 and 静态方法

静态方法只能访问静态，非静态方法可以访问所有， 静态方法没有this关键字



## 继承

```java
public class Son extends Father {
    
}

```

Son 是子类， 派生类
Father是父类， 基类超类

java只支持单继承， 不支持多继承， 即一个子类只能有一个父类

java支持多层继承

java所有类都直接或者间接继承于Object类
什么可以继承

构造方法：非私有不能， 私有不能

成员变量：非私有能， 私有能

成员方法：非私有能， 私有不能
继承中的访问：就近原则
`super`关键字， 子类访问父类的成员变量
子类构造方法默认先访问父类的无参构造，再执行自己
子类构造方法的第一行语句默认都是`super()`, 不写也存在，且必须在第一行
如果想调用父类的有参构造，必须手动写super
```java
调用父类的带参构造
 super(name, size)；
```
## 多态
同类型的对象， 表现出不同的形态
`父类类型 对象名称 = 子类对象`
多态的前提 有继承、实现关系；有父类引用指向子类对象；有方法的重写
多态调用，成员变量：编译看左边， 运行和看左边； 成员方法：编译看左边，运行也看右边
优势：解耦合，便于维护；定义方法时，以父类型作为参数，可以接受所有子类对象

```java
 a instanceof B // 判断对象a是不是类B地一个实例
```
## 包
* 使用同一个包的类时，不需要导入包
* 使用java.lang包中的类不需要导入包
* 其它情况都需要导包
* 使用两个包的同名类，需要使用全类名
## final
final修饰方法，表示该方法是最终方法不能被重写
final修饰类，表示该类是最终了类不能被继承
final修饰的变量， 存储的值不能改变
final修饰引用类型， 那么变量存储的地址值不能发生改变， 对象内部的可以改变
## 权限修饰符
private: 只能同一个类
默认：自己类， 同一个包的其他类
protected 同一个包 同一个包的其他类 其它包的子类
public 同一个包 同一个包的其他类 其它包的子类 其他包的无关类
## 静态代码块
随着类的加载而执行的， 并且只执行一次， 比如上次周赛静态生成回文数的代码`static{语句}`
```java
    static long[] A = new long[109999];
    // 生成1e9内的回文数字
    static {
        int idx = 0;
        for (long i = 1; i <= 100000; ++i) {
            long p = i;
            for (long x = i / 10; x > 0; x /= 10) {
                p = p * 10 + x % 10;
            }
            if (p < 1000000000) {
                A[idx++] = p;
            }
            p = i;
            for (long x = i; x > 0; x /= 10) {
                p = p * 10 + x % 10;
            }
            if (p < 1000000000) {
                A[idx++] = p;
            }
        }
        Arrays.sort(A);
    }
```
## 抽象类&&抽象方法

抽象方法: 子类的某个方法可能不一样, 在父类声明为抽象方法

抽象类: 一个类中存在抽象方法, 那么该类就必须声明为抽象类

抽象方法`public abstract int dp(int i, int j);`

抽象类定义`public abstract class A {}`

抽象类不能实例化, 抽象类的子类要么重写所有抽象类的抽象方法, 要么是抽象类

## 接口

定义`public interface 接口名 {}`

接口不能实例化, 接口和类是实现关系 关键字implements 

`public class 类名 implements 接口名{}`

接口的子类(实现类) : 重写接口中的所有抽象方法, 或者是抽象类

一个类可以实现多个接口`public   class implements 接口名1 接口名2{}`

实现类可以继承一个类的同时实现多个接口

`public class 类名 extends 父类 implements 接口名1, 接口名2 {}`

接口中成员变量: 只能是常量, 默认是`public static final`

没有构造方法

成员方法: 只能是抽象方法, 默认修饰符`public abstract`

JDK7以前接口只能定义抽象方法

JDK8的新特性: 接口中可以定义有方法体的方法

JDK9的新特性: 接口中可以定义私有方法

接口和接口之间的关系: 可以单继承也可以多继承

## JDK8接口新增的方法

JDK8允许在接口中定义默认方法, 需要使用`default`关键字, 作用是解决接口升级的问题`public default 返回值类型 方法名(参数列表) {}`

JDK8允许在接口中新增静态方法`public static 返回值类型 方法名(){}`注意静态方法只能通过接口名调用, 不能通过类名或者对象名字调用

## JDK9接口新增的私有方法

私有方法可以是静态的, 也可以是非静态的

接口代表规则是行为的抽象, 要想让哪个类拥有一个行为, 那么让这个类实现对用的接口就可以了,

当一个方法的参数是接口时, 可以传递接口所有实现类的对象, 这种方式被称为接口多态

## 适配器设计模式

当一个接口中的抽象方法过多, 但是我只需要使用一部分, 就可以采用适配器设计模式

编写中间类`XXXAdapter` 实现对应的接口, 对接口中的抽象方法进行空实现

让真正的实现类继承中间类, 并重写需要用的方法

为了避免其它类创建适配器的对象, 中间的适配器类用用abstract修饰

## 内部类

为了让外部获取内部类对象, 写一个get方法 `Object obj = outer.getInter()`

JDK16前内部类不能有静态变量吗, JDK17后才可以

静态内部类, 静态方法: 外部类名.内部类名.方法();, 非静态方法, 先创建对象再对象调用

局部内部类, 类定义在方法里面

**匿名内部类**: 本质是隐藏了名字的内部类

```java
new 类名或接口名() {
    重写方法
};
```

使用场景接口的实现类只需要使用一次, 可以使用匿名内部类简化代码

例如 在InnnerClassDemo7类的main()方法中使用PersonDemo类的pd对象调用method(Person p)方法，向person接口变量p传递一个匿名子类对象，重写Person接口的study()方法

```java
package cn.num07;
 
interface Person {
    void study();
}
 
class PersonDemo {	
    public void method(Person p) { 
        p.study();
    }
}
 
public class InnerClassDemo7 {
    public static void main(String[] args) {
        PersonDemo pd = new PersonDemo();
        pd.method(new Person() { // 向 person 接口变量 p 传递一个匿名子类对象
            @Override
            public void study() { // 重写 Person 接口的 study() 方法
                System.out.println("我正在学习Java编程语言");
            }
        });
    }
}
```

## Math

```java
Math.PI;
Math.max();
Math.seil(); // 向上取整
Math.floor(); // 向下取整
Math.round(); // 四舍五入
```

## System

```java
exit(); // 关闭当前虚拟机
long currentTimeMills(); // 当前系统事件的毫秒值形式, 从1970年1月1日00:00:00开始计算的
```

## RunTime

```java
// 当前虚拟机的运行环境
// 非静态
Runteme rt = Runtime.getRuntime(); // 获取系统运行环境对象
exit();
availableProcessors(); // 获取CPU的线程数
maxMemory(); // JVM可以从系统获取总内存大小
totalMemory(); // JVM已经从系统获取总内存大小(Byte)
freeMemory(); // JVM升序内存
exec(""); // 运行cmd命令
```

## Object&&Objectc

Object顶级父类, 所有类直接间接继承Object

```java
Object(); // 空参构造
toString(); // 重写ToString, 打印对象
euals(); // 不重写, 比较的是地址值, 重写比较的是属性
clone(); // 对象克隆, A对象的属性值完全拷贝给B对象
// 这个clone是浅克隆
```

浅克隆: 不管对象的属性是基本数据类型还是引用数据类型, 都完全拷贝过来

深克隆: 基本数据类型拷贝过来, 引用数据类型会重新创建新的,即修改被克隆对象的任何属性都不会影响到克隆出来的对象

## BigInteger && BigDecimal

大整数和大小数

```java
BigInterger(int a, new Random()); // [0~2^a -1]的随机大整数
BigInterger(string s); // 获取指定的大整数
BigInterger(string s, int radix); // 获取指定的大整数, 指定进制
add();
subtract();
multiply();
divide();
max(); min();
equals();
intValue(); // 转int
```

 bigDecimal类似

## 正则表达式

校验字符串是否满足一定的要求

### 字符类, 只匹配一个字符;

```java

[abc] // 只能是abc中的一个
[^abc] // 除了abc之外的任何字符
[a-zA-Z]
[a-d[m-p]] // a-d或者是m-p之间
[a-z&&[def]] // 取交集a-z和def的交集
[a-z&&[^bc]] // a-z和非bc的交集
[a-z&&[m-p]]
```

### 预定义字符, 只匹配一个字符

```java
. 任何字符;
\d 一个数字;
\D 非数字;
\s 一个空白字符  比如\t \n \x0B \f \r;
\S 非空白字符;
\w [a-zA-Z_0-9]字母数字下划线;
\W 非单词字符
```

### 数量词

```java
X? X, 一次或0次;
X* X, 零次或多次;
X+ X, 一次或多次;
X{n} X, 正好n次;
X{n,} X, 至少n次数;
X{n, m} X,[n :m]次数;
忽略单个字母的大小写((?i)a);
(?i)忽略后面字符的大小写;
() 分组;
```

例子

```java
    public static void myReg() {
        System.out.println("abcdefg".matches("[a-z]{2,88}"));
        String regexPhoneNumber = "1[3-9]\\d{9}"; // 第一位是1, 第二位是3-6, 后面9位是任意数字
        String myPhone = "18801597122";
        System.out.println(myPhone.matches("1[3-9]\\d{9}"));
        String regexFixedPhone = "0" + // 第一位是0
                "\\d{2,3}" +// 区位号长度2-3
                "-?" + // 可以有-, 也可以没有
                "[0-9^0]" + // 电话号码不能用0开头
                "\\d{4,9}"; // 5-10位的号码减去第一位, 4-9;
        System.out.println("03194882808".matches(regexFixedPhone));
        // 邮箱
        String regexEmail = "\\w+" +
                "@" +
                "[\\w&&[^_]]{2,6}" + // .左边不能出现下划线
                "." +
                "[a-zA-Z]{2,3}"; // 字母2-3次数
        System.out.println("2211916133@qq.com".matches(regexEmail));
        // 24小时制时间
        String timeRegex = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
        System.out.println("15:88:31".matches(timeRegex));
    }
```

### 正则表达式对象

```java
// 正则表达式对象
Pattern p = Pattern.compile("([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"); // 24小时时间
String str = "fhudiasfbiufbdifu15:15:48dsabyudi00:00:00你好没用的东西15:59:56";
// 文本匹配器对象, 找到符合规则的子串
Matcher m = p.matcher(str);
while (m.find()) {
    String s1 = m.group();
    System.out.println(s1);
}
```

### 捕获分组和非捕获分组

```java
\\组号 把第x组的内容再用一次;
判断以恶搞字符串的开始字符和结束字符是否一致:
String regex = "(.).+\\1";
判断一个字符的开始部分和结束部分是否一致:
String regex = "(.+.).+\\1";

```

## Date类

```java
Date d = new Date(); // 创建对象表示当前时间
Date d = new Date(long date); // 创建对象某个时间
```

## SimpleDateFormat

简单格式的日期

## Calendar类

年月日, 日历类

## JDK8新增时间相关类

```java
Instant时间戳类;
Instant obj = new Instant.now(); // 当前时间
// 根据秒/毫秒/纳秒获取instant对象
Instant obj = Instant.ofEpochMilli(0L);
日历:
LocalDate; LocalTime; LocalDateTime;
工具类;
Duration;时间间隔(秒);
Period日期间隔(年月日);
ChronoUnit(日期间隔)
```

## 包装类

Integer

Long

Boolean

`toBinaryString(int i)`得到二进制字符串

`parseXXX()`类型转换

## Arrays

```java
Arrays.toString(int[] arr); // 打印普通数组
arrays.binarySearch(数组, 要查找的元素);
Arrays.fill(数组, 元素);
Arrays.sort(); 
Arrays.sort();
Arrays.sort(数组, 排序规则);
// 包装类排序
Integer[] arr = {1, 2, 3, 4, 5, 7};
Arrays.sort(arr, new Comparator<Integer>() {
    public int compare(Integer o1, Integer o2) {
        return o2 - o1; // 降序排序
    }
});
// 使用lambda表达式
Arrays.sort(arr, (Integer o1, Integer o2)->{
        return o2 - o1; // 降序排序
    }
);



```

## Lambda表达式

```java
() -> {
    
}
()内为形参
->固定格式
{}方法体
```

可以简化匿名内部类的书写

只能简化函数式接口的匿名内部类的书写

函数式接口: 有且仅有一个抽象方法的接口

```java
例如:
Arrays.sort(arr1, (Integer o1, Integer o2) -> {
    	return o2 - o1; // 降序排序
	}
);
```

()内的参数类型可以省略不写

只有一个参数 参数类型可以省略不写, ()也可省略

Lambda表达式的方法体只有一行, 大括号分号return都可以省略不写, 需要同时省略

```java
简化版本;
Arrays.sort(arr1, (o1, o2) -> o2 - o1);
```

##  单列集合顶层接口`Collection`

List: ArrayList, LinedList Vector

Set: TreeSet, Hashset: LinkedHashSet

```java
add();
Collections.addAll(list, a1, a2, a3);

```



## 迭代器遍历

```java
Iterator<String> it = list.iterator();
while (it.hasNext) {
    String str = it.next();
    sout(str);
}
```

## 增强for遍历

所有的单列集合和数组才可以用增强for遍历

修改增强for中的变量不会改变集合原本的数据

```java
for (Integer a : arr) {
    
}
```

## Lambda表达式遍历

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(100);
list.add(155);
list.forEach(a-> System.out.println(a));
```

## 泛型类, 泛型方法, 泛型接口

```java
ArrayList<Integer> arr = new ArrayList<Integer>();
// java的泛型是伪泛型
泛型类:
ArrayList<Integer> arr = new ArrayList<>();
泛型方法:
public class A<E> {
    public boolean add(E e) {
        ...
    }
}
```

## 泛型继承, 泛型通配符

泛型不具备继承性, 但是数据具备继承性

泛型通配符: ? 表示不确定类型

`? extends E:`表示可以传递E或者是E所有的子类类型

`? super E` 表示可以传递E或者E所有的父类类型

## 二叉树, 二叉搜索树, 平衡二叉树

## 平衡二叉树, 红黑树

## Set

### HashSet

```java
add();
clear();
remove(); // 根据对象删除
contain();
size();
```

hashSet底层是数组+链表+红黑树

set存的如果是自定义对象, 则必须重写`hashCode()`和`equals()`

### TreeSet

底层红黑树

## Map

### HashMap

```java
HashMap<Integer, Integer> mp = new hashMap<>();
put(key, value);
get(key); // 访问value
getOrDefault(key, defaultValue); //获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值
cnt.put(num, 1 + cnt.getOrDefault(num, 0)); // 实现cnt[x]++的功能
remove(key); // 删除元素
clear();
size(); // key的数量
遍历:
for (key : mp.keySet()) ; // 遍历key
for (value: mp.values()); // 遍历value值
putIfAbsent(); // 如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。
containsKey(); //检查 hashMap 中是否存在指定的 key 对应的映射关系。
containsValue(); //检查 hashMap 中是否存在指定的 value 对应的映射关系
forEach();	//对 hashMap 中的每个映射执行指定的操作。
merge();	//添加键值对到 hashMap 中
```

### TreeSet

方法同map

## Stream流

使用步骤: 先得到一条stream流, 把数据放上去; 中间非法; 中结非法

```;
获取流水线;
单列集合 stream();
双列集合, 不能直接获得, ketSet(), entrySet();
数组 stream(T[] array);
零散数据 of(T value)

```

### 单列集合Stram流

```java
 ArrayList<String> list = new ArrayList<>();
list.add("1");
list.add("222");
Stream<String> st = list.stream(); // 获取流水线
// 使用终结方法打印
st.forEach(new Consumer<String>() {
    @Override
    public void accept(String s) {
        System.out.println(s);
    }
});
// 简写为Lambda
list.stream().forEach(s-> System.out.println(s));
```

### 双列集合

```java
HashMap<String, Integer> mp = new HashMap<>();
mp.put("aaa", 1);
mp.put("bbb", 2);
// 获取stream流
mp.keySet().stream().forEach(s -> System.out.println(s));
mp.entrySet().stream().forEach(s -> System.out.println(s));; // 键值对对象
```

### 数组Stream流

```java
int[] arr = {1, 2, 3, 4};
Arrays.stream(arr).forEach(s -> sout(s));
```

### 零散数据Stream流

```java
Stream.of(1, 2, 4, 5).forEach(s->sout(s));
```

### Stream流中间方法

```java
fliter(); // 方法中true留下false不要
limit(long maxsize); // 获取前几个
skip();
distinct(); // 去重需要HashCode方法和Equals方法
concat(); // 合并两个流
map(Function<T, R> mapper()); // 转换
```

### Stream流终结方法

```java
forEach(); // 遍历
count(); // 统计
toArray(); // 收集到数组中
collect(); // 收集到集合中
String[] arr = s.stram().toArray();
ArrayList<Integer> ans = list.stream().collect(Collectors.toList());
lsit.stream().collect(Collectors.toMap(Function1, Function2);`
```

## 引用方法

```java
Integer[] arr = {1, 2, 3, 4, 5, 66667777, 8788, 8999};
Arrays.sort(arr, StreamDemo::cmp);
System.out.println(Arrays.toString(arr));
```

```java
引用构造方法:
类名::new();
引用数组的构造方法:
Integer[] arr = list.stream().toArray(Integer[]::new);
```

## 异常

Error 系统错误

Exception异常, 程序可能出现的问题

* RuntimeException运行是异常如数组越界

* 编译时异常

* 异常可以查看bug
* 异常可以作为方法内部的特殊返回值

### 捕获异常(自己处理异常)

```java
try {
    可能出现异常的代码
    // 此处出现了异常, 程序就会在这里创建一个Exception 对象;
    // 拿着这个对象和下面小括号对比, 看括号中的变量是否能够接受这个对象
    // 如果可以被接受, 表示这个异常被捕获
} catch (异常类名 变量名) {
    异常的处理代码
}

```

* 如果捕获多个异常, 写多个catch, 细节: 异常中存在父子关系的话, 父类写在下面
* JDK 7之后, 可以一个catch捕获多个异常 catch(E e | E1 a) 
* 如果try的异常没有被捕获, 采用虚拟机默认的异常处理方式

### 异常常见方法

```java
e.getMessage();
sout << e.toString();
e,printStackTrace();
```

### 抛出异常

```java
throws 写在方法定义处
throw 写在方法内, 结束方法
public class C{
    public void method() throws 异常1, 异常2 {
        if () {
            throw 异常1
        }
        if () {
            throw 异常2
        }
    }
}

```

### File类

```java
File f = new File("路径");
成员方法:创建和删除
boolean exists();
etc
creatNewFile();
mkdir(); // 创建单级文件夹
mkdirs(); // 创建多级文件夹
delete();
遍历:
File[] fs = f.listFiles();
for (File oneFile : fs) {}
```



## IO流

字节流和字符流

### 字节流

```java
InputStream(); 子类:FileInputStream()
OutputStream(); 子类FileOutputStream();
例如:
FileOutputStream fo = new FileOutputStream("test1.txt");
fo.write(87);
fo.close();
// 写的都是字节流
public static void Fil() throws IOException {
    FileOutputStream fo = new FileOutputStream("test1.txt");
    String s1 = "dsjaiofnoasifo";
    byte[] byte1 = s1.getBytes();
    fo.write(byte1);
    fo.close();
}
```

```java
InputStream(); 子类:FileInputStream();
FileInputStream fo = new FileInputStream("test1.txt");
int a = fo.read();
fo.close();
// 一次读取一个字节, 读到文件末尾了, read()返回-1

// 循环读取
int b;
while ((b = fo.read()) != -1) {}
```

### 字符流

默认一次读取一个字节, 遇到中文, 一次读取多个字符

```java
FileReader;
FileWriter;

```

##  多线程&JUC

 线程: 操作系统运行调度的最小实体, 被包含在进程中

并发: 同一时刻多个指令在单个CPU上交替运行

并行: 同一时刻, 多个线程在多个CPU上同时执行

 ### 多线程Thread类

```java
public class ThreadMemo {
    // 多线程方法一:
    // 自己定义一个类, 继承Thread类
    // 重写run方法
    // 创建子类对象, 启动线程
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // 开启线程
    }
}
// 是并发的, 例如
MyThread t1 = new MyThread();
MyThread t2 = new MyThread();
t1.setName("进程1");
t2.setName("进程2");
t1.start(); // 开启线程
t2.start();
两个线程交替进行
```

### Runnable接口的实现方式

```java
// 创建自己的类, implement Runnable接口
// 重写接口的run方法
// 创建自己的类的对象
// 创建一个Thread类的对象, 并开启线程
public class MyRun implements Runnable {
    @Override
    public void run() {
        // 获取当前进程的对象
        Thread t = Thread.currentThread();
        for (int i = 0; i < 100; ++i) {
            System.out.println(t.getName() + "HelloWorld");

        }
    }
}
public static void main(String[] args) {
        MyRun myRun = new MyRun();
        Thread t1 = new Thread(myRun); //创建线程对象
        Thread t2 = new Thread(myRun); //创建线程对象
        t1.setName("进程1");
        t2.setName("进程2");
        t1.start();
        t2.start();
    }
// 实现效果也是交替进行的
```

### 利用Callable接口和Future接口实现

```java
// 特点: 可以获取多线程运行的结果
// 创建一个类实现Callable接口
// 重写call方法(有返回值, 表示多线程运行的结果)
// 创建自己的类的对象(表示多线程要执行的任务)
// FutureTask对象, 管理多线程运行的结果
// 创建Thread对象, 启动表示线程
package com.edu.nju.test3;

import java.util.concurrent.Callable;

public class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int s = 0;
        for (int i = 0; i < 100; i++) {
            s += i;
        }
        return s;
    }
}

 public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCallable mc = new MyCallable(); // (表示多线程要执行的任务)
        FutureTask<Integer> ft = new FutureTask<>(mc); // 管理多线程运行的结果
        Thread t1 = new Thread(ft);
        t1.start();

        // 获取结果
        Integer a = ft.get();
        System.out.println(a);
    }
```

### 线程常用方法

```java
 getName();
setName();
static Thread currentThread(); // 获取当前线程的对象
static void sleep(long ms); // 哪个线程执行到这里, 就在这里停留
// 线程的调度: 抢占式调度,  非抢占式调度(轮流)
// Java是第一种

setDaemon(); // 设置守护线程(备胎线程), 用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了

public static void yield(); // 礼让线程, 线程礼让是指在某个特定的时间点，让线程暂停抢占CPU资源的行为，运行状态/就绪状态–》阻塞状态，将CPU资源让给其他的线程来使用

// 插入线程
public final void join(); // 把子线程插入到主线程之前，等子线程里面所有的代码全部执行完了，才会轮到主线程去执行！
// 总结：哪个线程调用了join()，哪个线程就插入到当前线程之前, 当插入线程执行完了才会执行别的
```

* 线程优先级:
  * 默认值是5
  * 最小是1, 最大是10, main方法的优先级默认5

### 线程的生命周期

新建

就绪(有执行资格没有执行权) <_> 运行(有资格有执行权)  && 阻塞 (没有执行资格没有执行权)

死亡

### 线程安全

```java
// 同步代码块
synchronized (锁obj)
    操作共享数据的代码;
    // 锁默认打开, 有一个线程进去, 锁会自动关闭
    // 里面的代码执行完毕, 出来, 锁自动打开
}
// 保证锁obj是唯一的, 加static字段
static Object = new Object();

// 细节, 同步代码块不能放在循环外边
//     锁对象, 一定得是唯一的
```

```java
package com.edu.nju.test3;

public class Suo extends Thread {
    static int ticket = 0;
    static Object obj = new Object();

    @Override
    public void run() {
        super.run();
        while (true) {
            synchronized (obj) {
                if (ticket < 100) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    ++ticket;
                    System.out.println(getName() + "正在卖第" + ticket + "张票");
                } else {
                    break;
                }
            }
        }
    }
}
package com.edu.nju.test3;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class ThreadMemo {
    // 多线程方法一:
    // 自己定义一个类, 继承Thread类
    // 重写run方法
    // 创建子类对象, 启动线程
    public static void main(String[] args) throws ExecutionException, InterruptedException {
       Suo s1 = new Suo();
       Suo s3 = new Suo();
       Suo s2 = new Suo();
       s1.setName("窗口1");
       s2.setName("窗口2");
       s3.setName("窗口3");
       s1.start();
       s3.start();
       s2.start();

    }
}

```

### 同步方法

```java
直接把synchronized加在关键字上;
// 同步方法是所住方法里面所有的代码
// 锁对象不能自己指定(非静态 this; 静态: 当前类的字节码文件对象)
```

```java
package com.edu.nju.test4;

import com.edu.nju.test3.MyCallable;

public class MyRunnable implements Runnable {
    int ticket = 0;

    @Override
    public void run() {
        while (true) {
            synchronized (MyCallable.class) {
                if (method()) break;
            }
        }
    }

    public synchronized boolean method() {
        if (ticket == 100) {
            return true;
        } else {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            ++ticket;
            System.out.println(Thread.currentThread().getName() + "正在卖第" + ticket + "张票");
        }
        return false;
    }
}

```

### lock锁

* 手动上锁, 手动释放锁

* lock是接口, 实例类ReentranLock

```java
static Lock lock = new ReentrantLock(); // 对象共享一把锁
lock.locK(); // 上锁
代码块
lock.unlock();
finally{} // try catch中一定会执行的部分,
// 锁释放写在lock中, 一定会执行
```

### 死锁

出现了锁的嵌套

```java
// 一个线程一把锁
public class demo2 {
    public static void main(String[] args) {
        synchronized (demo2.class) {//第一次上锁
            synchronized (demo2.class) {//第二次上锁
                ；
            }
        }
    }
}
//假如synchronized是不可重入锁, 第二次上锁依赖第一次上锁释放，第一次上锁的释放需要执行完第二次上锁里的代码，就这样，二者互相等待，就导致锁死了
```

```java
// 两个线程互相获取对方锁
public class demo2 {
    public static void main(String[] args) {
        Object o1 = new Object();
        Object o2 = new Object();
        Thread t1 = new Thread() {
            public void run() {
                synchronized (o1) {
                    try {
                        sleep(1000);//等待t2线程上好他的o2锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (o2) {
                        System.out.println(1);
                    }
                }
            }
        };
        Thread t2 = new Thread() {
            public void run() {
                synchronized (o2) {
                    try {
                        sleep(1000);//等待t1线程上好他的o1锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (o1) {
                        System.out.println(2);
                    }
                }
            }
        };
        t1.start();
        t2.start();
    }
}
//可见线程一先上了o1锁，线程二先上了o2锁，然后线程一需要等待线程二的o2锁释放获取到该锁执行完后续代码才能释放o1锁，但线程二也需要等待线程一的o1锁释放获取到该锁执行完后续代码才能释放o2锁。他俩就互相等待，锁死了
```

- 死锁的必要条件
  - 互斥使用
  - 不可抢占
  - 请求和保持
  - 循环等待（重点）：P1占用了P2的资源，P2占用了P3的资源，P3占用了P1的资源
- 破除循环等待方法：**锁排序**.有N个线程，M把锁，给锁编号，规定加锁顺序由小到大，这样就能避免环路等待；

```java
Object lock1 = new Object();
Object lock2 = new Object();
Thread t1 = new Thread() {
    @Override
    public void run() {
        synchronized (lock1) {
            synchronized (lock2) {
                // do something...
           }
       }
   }
};
t1.start();
Thread t2 = new Thread() {
    @Override
    public void run() {
        synchronized (lock2) {
            synchronized (lock1) {
                // do something...
           }
       }
   }
};
t2.start();
// 这样就会产生环路我们按照必须由小到大获取锁的顺序：先获取lock1，再获取lock2
// 将代码改为
Object lock1 = new Object();
Object lock2 = new Object();
Thread t1 = new Thread() {
    @Override
    public void run() {
        synchronized (lock1) {
            synchronized (lock2) {
                // do something...
           }
       }
   }
};
t1.start();
Thread t2 = new Thread() {
    @Override
    public void run() {
        synchronized (lock1) {
            synchronized (lock2) {
                // do something...
           }
       }
   }
};
t2.start();

```

### 等待唤醒机制

# SpringSSM

* 架构
  * 核心容器: Beans, Core, Context, SpEEL
  * AOP思想, 面向切片编程
  * Aspects AOP思想实现
  * Data Access数据访问: JDBC, ORM, OXM, JMS, Transactions
  * Web: WebSocket, Servlet, Web, Portlet

## 核心概念

* IOC, (Inversion of Control) 控制反转, 使用对象时, 不要自己new改为IOC容器外部提供对象, 对象创建权的转移称为控制反转
* IOC容器负责对象的创建初始化等, 被IOC创建或者管理的对象在IOC容器中被称为Bean
* DI依赖注入, 在IOC容器中建立Bean和Bean之间依赖关系的过程
* 目标: 充分解耦合,
  * 使用IOC管理Bean
  * 在IOC容器中将有依赖关系的Bean进行关系绑定,(DI依赖注入)
* 最终结果: 充分解耦, 实用对象不仅可以直接从IOC容器中获取, 并且获取到的Bean已经绑定了所有的依赖关系

## IOC入门案例

* 管理: service与dao
* 被管理的对象告知IOC: 配置
* 被管理的对象交给IOC容器, 如何获取到IOC容器: 接口
* 如何从IOC容器中获取Bean 接口方法
* 使用Spring导入哪些坐标? pom.xml
  *  业务层接口, 业务型实现类
  * 数据层接口, 数据层实现类(impl)

```java
// xml文件中导入spring坐标
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.2.10.RELEASE</version>
        </dependency>
    </dependencies>
        
 dao接口, dao实现类;
service接口, service实现类;

// 创建spring配置文件, 配置对应类作为spring管理的bean
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<!--导入spring坐标spring-context, 对应版本5.2.10.RELEASE-->

<!--    配置Bean-->
<!--    配置bean, 起名字, class定义类型-->
    <bean id="bookDaoImpl" class = "com.nju.dao.impl.BookDaoImpl"/>

    <bean id = "bookServiceImpl" class = "com.nju.service.impl.BookServiceImpl"/>
</beans>
        
// 容器中拿对象;
// 获取IOC容器
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        // 获取bean
        BookDao bookDao = (BookDao) ctx.getBean("bookDaoImpl");

        // 直接调用对象
        bookDao.save();

        BookService bookService = (BookService) ctx.getBean("bookServiceImpl");
        bookService.save();
```

## DI(Dependency Injection) 入门案例

* Service需要的Dao对象进入service, 提供方法

```xml
 <bean id="bookServiceImpl" class="com.nju.service.impl.BookServiceImpl">
        <!--        配置service与dao的关系-->
<!--        property标签表示配置当前bean的属性-->
        <!--        name 表示配置哪一个具体的属性-->
        <!--        ref表示参照哪一个bean-->
        <property name="bookDao" ref = "bookDaoImpl"/>
    </bean>
```

## Bean配置

id     class

name指定别名

spring默认提供单例类, scope = "singleton"; scope = "prototype"非单例类

## Bean实例化
### 构造方法
* 构造方法写成私有, Spring仍旧可以构造对象, (反射)
* Spring构造Bean默认调用无参构造方法
报错, 从最下边的异常往上看
### bean实例化  静态工厂(了解)

```xml
<bean id = "orderDao" class = "com.nju.factory.OrderDaoFactory" factory-method = "getOrderDao"/>
```

### 实例化工厂与FactoryBean

```xml
先造工厂bean
<bean id="userFactory" calss="com.nju.factory.UserDaoFactory"/>
造自己的bean
<bean 
      id="userDao" 
      factoty-method="" 
      factory-bean="userFactory"
      />
```

```xml
FactoryBean实例化
<bean id="userDao" class=".UserFactoryBean">;
```

### bean的生命周期

配置文件配置生命周期方法 

关闭IOC容器才可以执行destory方法`ctx.registerShutdownHook()`关闭容器钩子

`ctx.close()`更暴力

init-method=""

destory-method=""

implement两个接口InitializingBean, DisposableBean 

```java
public class BookDaoImpl implements BookDao, InitializingBean, DisposableBean {
    public void save() {
        System.out.println("book dao save ...");
    }


    @Override
    public void destroy() throws Exception {
        System.out.println("销毁bean方法");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("创建Bean");
    }
}
public class APP2 {
    public static void main(String[] args) {
        // 获取IOC容器
        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        // 获取bean
        BookDao bookDao = (BookDao) ctx.getBean("bookDaoImpl");
        // 直接调用对象
        bookDao.save();
//        System.out.println(bookDao);
        ctx.close();

    }
}
```

## DI依赖注入

简单类型: 基本数据类型和String

引用类型



### setter注入

```xml
 <property name="bookDao" ref = "bookDaoImpl"/>
```



### 构造器注入

constructor-arg中的ref属性
constructor-arg标签的ref属性用于注入另一个bean作为参数，被注入的bean会在当前bean实例化时自动注入到当前bean的构造函数中。使用方法如下：

```xml
<constructor-arg name = 'bookDao' ref="bookDaoImpl"/>
```

name是形参, ref是引用的bean



简单类型

```xml
<constructor-arg name="形参1" value="形参值1">
```

问题: 现在配置文件和参数的名字都是必须一样的, 耦合度高

可以不写形参名字,  标好type,(解决形参名称的问题)

* 可以index标注是第几个参数(0, 1, 2)

```java
    private BookDao bookDao;
    String name;
    int num;

    public BookServiceImpl(BookDao bookDao, String name, int num) {
        this.bookDao = bookDao;
        this.name = name;
        this.num = num;
        System.out.println(bookDao + ", " + name + "," + num);
    }
```

```xml
    </bean>
    <bean id="bookServiceImpl" class="com.nju.service.impl.BookServiceImpl">
        <constructor-arg index="0" ref="bookDaoImpl"/>
        <constructor-arg index="1" value="mysql"/>
        <constructor-arg index="2" value="200"/>
    </bean>
```

### 依赖注入方式选择

* 强制依赖使用构造器
* 可选依赖使用setter注入
* Spring倡导使用构造器'
* 自己开发的模块推荐使用setter注入

### 依赖自动装配 
* IOC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配
* 主要是按名称和按工程

按类型, 只要写够set方法, 写autowire bytype即可, 按名称匹配要求匹配类型必须唯一

```xml
 <bean id="bookServiceImpl" class="com.nju.service.impl.BookServiceImpl" autowire="byType"/>
```

按名称匹配 byname

自动装配只用于引用类型, 不用于简单类型

如果按名称装配, 要求容器中必须存在指定名称的bean

### 集合注入

```xml
<property name="set">
    <set>
        <value>1</value>
        <value>2</value>
    </set>
</property>
```

### Spring管理第三方对象

pom.xml文件导入坐标

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>
```

配置管理的对象的bean

```xml
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://127.0.0.1:3306/spring_db"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </bean>
```

### 加载properti文件

* 创建spring命名空间, context命名文件
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd

       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
">
```

**在resources中创建properties文件**



**使用context空间加载properties文件**

```xml
<context:property-placeholder location="jdbc.properties"/>
```

**使用属性占位符读取properties中的属性**

```xml
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
```

**标准格式**

```xml
    <context:property-placeholder location="classpath*:*.properties" system-properties-mode="NEVER"/>
```

 可以从jar包中获取properties文件

### 容器

加载配置文件

```java
ApplicationContext ctx1 = new ClassPathXmlApplicationContext("applicationContext.xml");xxxxxxxxxx AppApplicationContext ctx1 = new ClassPathXmlApplicationContext("applicationContext.xml");
```

获取beans

```java
BookDao bk = ctx.getBean(BookDao.class); // 类型的bean只能有一个
BookDao bk = (BookDao) ctx.getBean("bookDao");
```
## 注解开发
### 注解开发定义bean
* 类@compent 定义bean
* 核心配置文件中通过组件扫描加载bean`<context:compent-scan base-package="com.nju"/>`
  * 建议业务层`@service`, 
  * 数据层`@Repository` 
  * 表现层`@Controller`

### 纯注解开发模式

```java
@Configuration // 当前类为配置类
@ComponentScan("zhujie") // 扫描路径, 多个{"", "", ""}
public class CCC {
}
// 加载配置类初始化容器
        ApplicationContext ctx = new AnnotationConfigApplicationContext(CCC.class);
```

### bean管理

* @Scope("prototype") 非单例模式
* @Scope("singleton ") 单例模式
* @PostConstruct
* @PreDestroy

### 依赖注入

* @AutoWired自动装配引用类型
* @Value("val") 简单类型注入
* 使用@Qualifier("name")指定名称
* @PropertySource("")导入properties文件, 用的话

### 注解开发管理第三方bean

定义一个方法获得要管理的对象

方法中资源注入, 简单类型直接value注入, 引用类型 直接填在形参中

添加@Bean表示当前方法的返回值是一个bean

手动设置属性

* 方式1使用独立的配置类, 将独立的配置类加入核心配置@Import

### 注解开发总结

## Spring整合MyBatis

整合Mybatis坐标

mysql, mybatis, spring-jdbc, mybatis-spring

```xml


```

### Junit整合

* @RunWith(SpringJUnit4ClassRunner.class)专用的类加载器
* @ContextConfiguration(classes = SpringConfig.class)
  * @AutoWired

## AOP

面向切面编程, OOP面向对象编程

不惊动原始设计的基础上为其进行功能增强(无入侵性质)

连接点, 在Spring中, 理解为方法的执行

切入点: 匹配连接点的式子

通知, 在切入点处执行的操作, 通知类: 定义通知的类. 切面: 描述通知和切入点的关系

```java
@Configuration
@ComponentScan("com.test")
@EnableAspectJAutoProxy // 告诉Spring有用注解开发的bean
public class SpringConfig {
    // 配置类
}

@Component
@Aspect

public class MyAdvice {
    // 切入点
    @Pointcut("execution(void com.test.BookDao.update())")
    private void pt(){}

    // 绑定切入点和方法的关系
    @Before("pt()")
    public void method() {
        System.out.println(System.currentTimeMillis());
    }
}
```

目标对象, 代理模式

### AOP切入点表达式

```java
execution(public void 包名.类名.方法名());
通配符*;
..匹配多个连续任意符号;
+专用于匹配子类类型;
```

切入点:

```java
@Before("pt()")
@After("pt()")
// 环绕, 前后都有, 中间有一句话表示原函数调用
@Around("pt()") 
public Object around(ProceedingJoinPoint pjp) {
    ...//
    pjp.proceed();
    ...//
}
// 绑定切入点和方法的关系
    @Around("pt()")
    public Object method(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println(System.currentTimeMillis());
        Object obj = pjp.proceed();
        System.out.println("方法结束");
        return obj;
    }
@AfterReturning
@AfterThowning
```

例子

```java
// 匹配业务层的所有方法
@Pointcut("execution(*com.nju.service.*Service.*(..))")
pjp.getDeclaringType() // 类名字
pjp.getName(); // 方法名
```

### Spring事务 Spring角色

事务相关配置

## MVC

web层(表现层)开发技术

请求与响应

Web框架

### MVC入门案例

导坐标, 控制器, 做springMVC控制类加载控制器 servlet容器控制类加载springmvc配置 

创建SpringMVC控制器类

```xml
    <dependencies>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>3.1.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.2.10.RELEASE</version>
        </dependency>
    </dependencies> 
```

创建web项目, maven Archetype选webAPP

Web项目运行 add Configure-maven

```xml
tomcat导包
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>tomcat7-maven-plugin</artifactId>
                <version>2.1</version>
                <configuration>
                    <port>80</port>
                    <path>/</path>
                </configuration>
            </plugin>
        </plugins>
    </build>
```

```java
// 使用controller定义bean
@Controller
public class UserController {
    // 设置当前操作的访问路径
    @RequestMapping("/save")
    // 设置当前操作的返回类型
    @ResponseBody
    public String save() {
        System.out.println("User Save功能执行");
        return "{'module':'springmvc'}";
    }
}
// 定义一个servlet容器启动的配置类, 在里面加载spring配置

public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer {
    // 加载springMVC配置
    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        ctx.register(SpringMvcConfig.class);
        return ctx;
    }

    // 配置哪些请求由MVC配置
    @Override
    protected String[] getServletMappings() {
        return new String[] {"/"};  // 所有请求
    }

    // 加载spring容器配置
    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
}
```

### Controller加载控制与业务bean加载控制

加载Spring控制的bean的时候, 排除掉SpringMVC控制的bean: 包精准扫描com.nju.controller

或者是com.nju排除不用的

```java
@componentScan(value="com.nju"
        excludeFilter = @ComponentFliter(
        type = FilterType.Annotation
        classes = Controller.class)) // 按注解排除
```

```java
//web配置类简化开发，仅设置配置类类名即可
public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {

    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}

```

### PostMan插件

发送http请求的chrome插件

  

### 请求与响应

设置请求映射路径 /模块/操作

```java
// 上面设置请求映射路径
@RequestMapping("/user")

```

```java
// 请求乱码处理
public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    //乱码处理
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter filter = new CharacterEncodingFilter();
        filter.setEncoding("UTF-8");
        return new Filter[]{filter};
    }
}


```

### 请求操作参数传递

pojoParam

ListParam

### json数据传参

```java
// java中json坐标
  <dependencies>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.9.0</version>
    </dependency>
```

springMvcConfig前@EnableWebMvc

开启json功能

```java
    //集合参数：json格式
    //1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc
    //2.使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据
    @RequestMapping("/listParamForJson")
    @ResponseBody
    public String listParamForJson(@RequestBody List<String> likes){
        System.out.println("list common(json)参数传递 list ==> "+likes);
        return "{'module':'list common for json param'}";
    }

    //POJO参数：json格式
    //1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc
    //2.使用@RequestBody注解将外部传递的json数据映射到形参的实体类对象中，要求属性名称一一对应
    @RequestMapping("/pojoParamForJson")
    @ResponseBody
    public String pojoParamForJson(@RequestBody User user){
        System.out.println("pojo(json)参数传递 user ==> "+user);
        return "{'module':'pojo for json param'}";
    }
    //集合参数：json格式
    //1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc
    //2.使用@RequestBody注解将外部传递的json数组数据映射到形参的保存实体类对象的集合对象中，要求属性名称一一对应
    @RequestMapping("/listPojoParamForJson")
    @ResponseBody
    public String listPojoParamForJson(@RequestBody List<User> list){
        System.out.println("list pojo(json)参数传递 list ==> "+list);
        return "{'module':'list pojo for json param'}";
    }
```



```json
// json数组
["game", "music", "traval"]
// Pojo参数
{
    "name": "itcast",
    "age" : 15
}

// 集合参数
[
    {"name":"itcast", "age":15},
    {"name":"nju", "age":15}
]
```



### 日期类型参数传递

```java
    //日期参数
    //使用@DateTimeFormat注解设置日期类型数据格式，默认格式yyyy/MM/dd
    @RequestMapping("/dataParam")
    @ResponseBody
    public String dataParam(Date date,
                            @DateTimeFormat(pattern="yyyy-MM-dd") Date date1,
                            @DateTimeFormat(pattern="yyyy/MM/dd HH:mm:ss") Date date2){
        System.out.println("参数传递 date ==> "+date);
        System.out.println("参数传递 date1(yyyy-MM-dd) ==> "+date1);
        System.out.println("参数传递 date2(yyyy/MM/dd HH:mm:ss) ==> "+date2);
        return "{'module':'data param'}";
    }
```

```json
http://localhost/dataParam?date=2088/08/08&date1=2088-08-08&date2=2088/08/08 23:15:01
```

