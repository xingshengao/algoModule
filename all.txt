#include <bits/stdc++.h>
#define int long long
using namespace std;

#define all(c) c.begin(), c.end()
#define REP(i, a, b) for (int i = a; i < (b); i++)
#define RREP(i, a, b) for (int i = a; i >= b; i--)
#define print(x) cout << x << endl
using LL = long long;
using VI = vector<int>;
using VL = vector<LL>;
using VVI = vector<vector<int>>;
using VVL = vector<vector<LL>>;
using VD = vector<double>;
using VVD = vector<vector<double>>;
using PII = pair<int, int>;
using PLL = pair<long long, long long>;
using TIII = tuple<int, int, int>;
using TLLL = tuple<LL, LL, LL>;
using VPII = vector<PII>;
using VVVI = vector<vector<vector<int>>>;
using VVVL = vector<vector<vector<LL>>>;

template <class T>
void mkuni(vector<T>& v) {
    sort(all(v));
    v.erase(unique(all(v)), v.end());
}

template <class T, class S = T>
S SUM(const vector<T>& a) {
    return accumulate(a.begin(), a.end(), S(0));
}

template <class T>
T MAX(const vector<T>& a) {
    return *max_element(a.begin(), a.end());
}

template <class T>
T MIN(const vector<T>& a) {
    return *min_element(a.begin(), a.end());
}

template <class T>
bool chmin(T& a, const T& b) {
    return b < a ? a = b, 1 : 0;
}  // set a = min(a,b)

template <class T>
bool chmax(T& a, const T& b) {
    return a < b ? a = b, 1 : 0;
}  // set a = max(a,b)

const double PI = acos(-1);
vector<pair<int, int>> dirs8 = {{-1, -1}, {-1, 1}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {1, -1}, {1, 0}};
vector<pair<int, int>> dirs4 = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};

long long fpow(long long x, long long exp, long long mod) {  // 快速幂
    long long res = 1;
    for (; exp; exp /= 2) {
        if (exp & 1) res = res * x % mod;
        x = x * x % mod;
    }
    return res;
}

long long fpow(long long x, long long exp) {  // 快速幂
    long long res = 1;
    for (; exp; exp /= 2) {
        if (exp & 1) res = res * x;
        x = x * x;
    }
    return res;
}
bool isdig(char x) { return x >= '0' && x <= '9'; }
bool isup(char x) { return x >= 'A' && x <= 'Z'; }
bool isdown(char x) { return x >= 'a' && x <= 'z'; }
bool islet(char x) { return isup(x) || isdown(x); }

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

template <typename T>
ostream& operator<<(ostream& out, const set<T>& obj) {
    out << "set(";
    for (auto it = obj.begin(); it != obj.end(); it++) out << (it == obj.begin() ? "" : ", ") << *it;
    out << ")";
    return out;
}
template <typename T>
ostream& operator<<(ostream& out, const unordered_set<T>& obj) {
    out << "unordered_set(";
    for (auto it = obj.begin(); it != obj.end(); it++) out << (it == obj.begin() ? "" : ", ") << *it;
    out << ")";
    return out;
}
template <typename T1, typename T2>
ostream& operator<<(ostream& out, const map<T1, T2>& obj) {
    out << "map(";
    for (auto it = obj.begin(); it != obj.end(); it++) out << (it == obj.begin() ? "" : ", ") << it->first << ": " << it->second;
    out << ")";
    return out;
}
template <typename T1, typename T2>
ostream& operator<<(ostream& out, const unordered_map<T1, T2>& obj) {
    out << "unordered_map(";
    for (auto it = obj.begin(); it != obj.end(); it++) out << (it == obj.begin() ? "" : ", ") << it->first << ": " << it->second;
    out << ")";
    return out;
}
template <typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& obj) {
    out << "<" << obj.first << ", " << obj.second << ">";
    return out;
}
template <typename T>
ostream& operator<<(ostream& out, const vector<T>& obj) {
    out << "vector(";
    for (auto it = obj.begin(); it != obj.end(); it++) out << (it == obj.begin() ? "" : ", ") << *it;
    out << ")";
    return out;
}

string to_string(string s) { return '"' + s + '"'; }

string to_string(const char* s) { return to_string((string)s); }

string to_string(bool b) { return (b ? "true" : "false"); }

template <typename A, typename B>
string to_string(pair<A, B> p) {
    return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";
}

template <typename A>
string to_string(A v) {
    bool first = true;
    string res = "{";
    for (const auto& x : v) {
        if (!first) res += ", ";
        first = false;
        res += to_string(x);
    }
    res += "}";
    return res;
}

void debug_out() { cout << endl; }

template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
    cout << " " << to_string(H);
    debug_out(T...);
}

template <typename T>
void mydebug(const char* format, T t) {
    cout << format << "=" << to_string(t) << endl;
}

template <typename Head, typename... Tail>
void mydebug(const char* format, Head H, Tail... T) {
    while (*format != ',') cout << *format++;
    cout << "=" << to_string(H) << ",";
    mydebug(format + 1, T...);
}
#define debug(...) mydebug(#__VA_ARGS__, __VA_ARGS__)





// 并查集
struct DSU {
    vector<int> f, siz;
    DSU() {}
    DSU(int n) { init(n); }
    void init(int n) {
        f.resize(n);
        iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
    bool same(int x, int y) { return find(x) == find(y); }
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
    int size(int x) { return siz[find(x)]; }
};





// 树状数组
template <typename T>
struct Fenwick {  // 使用n个需要开n-1, 即为Fenwick<int> fen(n + 1);
    int n;
    std::vector<T> tr;

    Fenwick(int n = 0) { init(n); }
    int low_bit(int x) { return x & -x; }
    void init(int n) {
        this->n = n;
        tr.assign(n, T());
    }

    void add(int pos, T v) {
        for (; pos < tr.size(); pos += low_bit(pos)) tr[pos] += v;
    }

    T query(int pos) {
        auto res = T();
        for (; pos; pos -= low_bit(pos)) {
            res += tr[pos];
        }
        return res;
    }
    // [l, r]
    T rangeSum(int l, int r) { return query(r) - query(l - 1); }
};
void LiSanHua() {  // 离散化的代码
    vector<LL> arr;
    // 要进行树状数组前缀和的点去重
    auto Uni = [](vector<LL>& A) -> vector<LL> {
        vector<LL> ans(A);
        sort(ans.begin(), ans.end());
        ans.erase(unique(ans.begin(), ans.end()), ans.end());
        return ans;
    };
    // 要进行离散化的数组, 可以是x可以是y
    vector<LL> A = Uni(arr);
    // 离散化
    map<LL, LL> mp;
    for (int i = 0; i < A.size(); ++i) {
        mp[A[i]] = i + 1;
    }
    Fenwick<LL> fen(A.size() + 1);
}





// 线段树_区间最大值
template <class Info>
struct SegmentTree {
    int n;
    std::vector<Info> info;
    SegmentTree() : n(0) {}
    SegmentTree(int n_, Info v_ = Info()) { init(n_, v_); }
    template <class T>
    SegmentTree(std::vector<T> init_) {
        init(init_);
    }
    void init(int n_, Info v_ = Info()) { init(std::vector(n_, v_)); }
    template <class T>
    void init(std::vector<T> init_) {
        n = init_.size();
        info.assign(4 << std::__lg(n), Info());
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) { info[p] = info[2 * p] + info[2 * p + 1]; }
    void modify(int p, int l, int r, int x, const Info& v) {
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x < m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info& v) { modify(1, 0, n, p, v); }
    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= y || r <= x) {
            return Info();
        }
        if (l >= x && r <= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) { return rangeQuery(1, 0, n, l, r); }
    template <class F>
    int findFirst(int p, int l, int r, int x, int y, F pred) {
        if (l >= y || r <= x || !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findFirst(2 * p, l, m, x, y, pred);
        if (res == -1) {
            res = findFirst(2 * p + 1, m, r, x, y, pred);
        }
        return res;
    }
    template <class F>
    int findFirst(int l, int r, F pred) {
        return findFirst(1, 0, n, l, r, pred);
    }
    template <class F>
    int findLast(int p, int l, int r, int x, int y, F pred) {
        if (l >= y || r <= x || !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findLast(2 * p + 1, m, r, x, y, pred);
        if (res == -1) {
            res = findLast(2 * p, l, m, x, y, pred);
        }
        return res;
    }
    template <class F>
    int findLast(int l, int r, F pred) {
        return findLast(1, 0, n, l, r, pred);
    }
};
struct Info {
    LL x;
    Info() { x = -1e18; }
    Info(LL x) { this->x = x; }
};

Info operator+(Info a, Info b) {
    Info ans;
    ans.x = max(a.x, b.x);
    return ans;
}
class Solution {
   public:
    int lengthOfLIS(vector<int>& nums, int k) {
        LL mx_val = *max_element(nums.begin(), nums.end());
        SegmentTree<Info> seg(mx_val + 1);  // 构建线段树
        LL ans = 0;
        for (LL num : nums) {
            // 对于每一个x, 使用线段树查询区间
            // [max(0, x - k), x]内的长度最大值
            LL len = seg.rangeQuery(max(0LL, num - k), num).x;
            ans = max(ans, len + 1);
            seg.modify(num, len + 1);
        }
        return ans;
    }
};





// 懒标记线段树，区间和
template <class Info, class Tag>
struct LazySegmentTree {
    const int n;
    std::vector<Info> info;
    std::vector<Tag> tag;
    LazySegmentTree(int n) : n(n), info(4 << std::__lg(n)), tag(4 << std::__lg(n)) {}
    LazySegmentTree(std::vector<Info> init) : LazySegmentTree(init.size()) {
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) { info[p] = info[2 * p] + info[2 * p + 1]; }
    void apply(int p, const Tag& v) {
        info[p].apply(v);
        tag[p].apply(v);
    }
    void push(int p) {
        apply(2 * p, tag[p]);
        apply(2 * p + 1, tag[p]);
        tag[p] = Tag();
    }
    void modify(int p, int l, int r, int x, const Info& v) {
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        push(p);
        if (x < m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info& v) { modify(1, 0, n, p, v); }
    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= y || r <= x) {
            return Info();
        }
        if (l >= x && r <= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        push(p);
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) { return rangeQuery(1, 0, n, l, r); }
    void rangeApply(int p, int l, int r, int x, int y, const Tag& v) {
        if (l >= y || r <= x) {
            return;
        }
        if (l >= x && r <= y) {
            apply(p, v);
            return;
        }
        int m = (l + r) / 2;
        push(p);
        rangeApply(2 * p, l, m, x, y, v);
        rangeApply(2 * p + 1, m, r, x, y, v);
        pull(p);
    }
    void rangeApply(int l, int r, const Tag& v) { return rangeApply(1, 0, n, l, r, v); }

    int search(int p, int l, int r, int x, int y, LL v) {
        if (l >= y || r <= x) return y;
        if (info[p].min >= v) return y;
        if (r - l == 1) return l;
        int m = (l + r) / 2;
        push(p);
        int res = search(2 * p, l, m, x, y, v);
        if (res == y) res = search(2 * p + 1, m, r, x, y, v);
        return res;
    }

    int search(int l, int r, LL v) { return search(1, 0, n, l, r, v); }
};

struct Tag {
    LL x;

    Tag(int _x = 0) : x{_x} {}

    void apply(const Tag& t) { x += t.x; }
};

struct Info {
    int l = 0;
    int r = 0;
    LL sum = 0;

    void apply(const Tag& t) { sum += t.x * (r - l); }
};

Info operator+(const Info& a, const Info& b) { return Info{min(a.l, b.l), max(a.r, b.r), a.sum + b.sum}; }

void solve() {
    int n, m;
    cin >> n >> m;
    vector<Info> infos(n);
    for (int i = 0; i < n; ++i) {
        LL x;
        cin >> x;
        infos[i] = Info{i, i + 1, x};
    }
    LazySegmentTree<Info, Tag> seg(infos);
    for (int _ = 0; _ < m; ++_) {
        int op;
        cin >> op;
        if (op == 1) {
            int x, y, k;
            cin >> x >> y >> k;
            seg.rangeApply(x - 1, y, k);  // 区间修改左闭右开区间
        } else {
            int x, y;
            cin >> x >> y;
            cout << seg.rangeQuery(x - 1, y).sum << endl;  // 区间查询, 左闭右开区间
        }
    }
}






// Z_function
std::vector<int> z_function(std::string s) {
    int n = (int)s.length();
    std::vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r && z[i - l] < r - i + 1) {
            z[i] = z[i - l];
        } else {
            z[i] = max(0LL, r - i + 1);
            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
        }
        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
    }
    return z;
}






// 使用KMP算法求出在text中, pattern出现的所有下标
std::vector<int> kmp(std::string& text, std::string& pattern) {
    int m = pattern.length();
    std::vector<int> pi(m);
    int c = 0;
    for (int i = 1; i < m; i++) {
        char v = pattern[i];
        while (c && pattern[c] != v) {
            c = pi[c - 1];
        }
        if (pattern[c] == v) {
            c++;
        }
        pi[i] = c;
    }

    std::vector<int> res;
    c = 0;
    for (int i = 0; i < text.length(); i++) {
        char v = text[i];
        while (c && pattern[c] != v) {
            c = pi[c - 1];
        }
        if (pattern[c] == v) {
            c++;
        }
        if (c == m) {
            res.push_back(i - m + 1);
            c = pi[c - 1];
        }
    }
    return res;
}




// split()
vector<string> split(typename string::const_iterator begin, typename string::const_iterator end, char val) {
    vector<string> res;
    string cur = "";
    for (auto it = begin; it != end; it++) {
        if (*it == val) {
            res.push_back(cur);
            cur.clear();
        } else
            cur.push_back(*it);
    }
    res.push_back(cur);
    return res;
}






// 字符串哈希双模数

struct String_hash {
    vector<long long> pre1, p1;
    vector<long long> pre2, p2;
    long long base1 = 131, base2 = 29;
    long long mod1 = 1e9 + 7, mod2 = 1e9 + 9;

    String_hash(string s) {  // 构造函数
        long long n = s.size();
        pre1.resize(n + 1);
        pre2.resize(n + 1);
        p1.resize(n + 1);
        p2.resize(n + 1);
        p1[0] = 1;
        p2[0] = 1;
        for (long long i = 0; i < n; i++) {
            p1[i + 1] = (long long)p1[i] * base1 % mod1;
            p2[i + 1] = (long long)p2[i] * base2 % mod2;
            pre1[i + 1] = (((long long)pre1[i] * base1 % mod1 + s[i] - 'a' + 1) % mod1 + mod1) % mod1;
            pre2[i + 1] = (((long long)pre2[i] * base2 % mod2 + s[i] - 'a' + 1) % mod2 + mod2) % mod2;
        }
    }

    LL get_hash1(int l, int r) {
        l++, r++;
        return ((pre1[r] - (long long)pre1[l - 1] * p1[r - l + 1] % mod1) % mod1 + mod1) % mod1;
    }

    LL get_hash2(int l, int r) {
        l++, r++;
        return ((pre2[r] - (long long)pre2[l - 1] * p2[r - l + 1] % mod2) % mod2 + mod2) % mod2;
    }
    PLL get_hash(int l, int r) { return PLL(get_hash1(l, r), get_hash2(l, r)); }
};
bool is_equal(string a, string b) {
    String_hash A(a), B(b);
    return (A.get_hash1(0, a.size() - 1) == B.get_hash1(0, b.size() - 1) && A.get_hash2(0, a.size() - 1) == B.get_hash2(0, b.size() - 1));
}

int main() {
    string a, b;
    cin >> a >> b;
    String_hash A(a), B(b);
    int n = a.size(), m = b.size(), res = 0;
    for (int i = 0; i + m - 1 < n; i++) {
        // 两个模数的哈希值都要相等
        if (A.get_hash1(i, i + m - 1) == B.get_hash1(0, m - 1) && A.get_hash2(i, i + m - 1) == B.get_hash2(0, m - 1)) res++;
    }
    cout << res << endl;
    return 0;
}




// 字符串编码
class StringEncode {
   public:
    static constexpr long long mod = 1e9 + 7;
    const long long base = 31;
    string s;
    long long n;
    vector<long long> preFix;                         // 编码前缀和
    vector<long long> mul;                            // 预先计算base的次幂
    long long encode(char c) { return c - 'a' + 1; }  // 字符编码函数
   public:
    StringEncode() {}
    StringEncode(string t) {
        s = t;
        n = s.size();
        preFix.resize(n + 1);
        mul.resize(n + 1);
        for (int i = 0; i < n + 1; ++i) {
            preFix[i] = 0;
            mul[i] = 1;
        }
        for (int i = 0; i < s.size(); ++i) {
            preFix[i + 1] = (preFix[i] * base + encode(s[i])) % mod;
            mul[i + 1] = (mul[i] * base) % mod;
        }
    }
    // 返回s的[l, r]子串的编码
    long long get_code(long long l, long long r) { return ((preFix[r + 1] - preFix[l] * mul[r - l + 1]) % mod + mod) % mod; }
};






// Mint 
using i64 = long long;
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
 
constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<i64 P>
struct MLong {
    i64 x;
    constexpr MLong() : x{} {}
    constexpr MLong(i64 x) : x{norm(x % getMod())} {}
    
    static i64 Mod;
    constexpr static i64 getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(i64 Mod_) {
        Mod = Mod_;
    }
    constexpr i64 norm(i64 x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr i64 val() const {
        return x;
    }
    explicit constexpr operator i64() const {
        return x;
    }
    constexpr MLong operator-() const {
        MLong res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MLong inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MLong &operator*=(MLong rhs) & {
        x = mul(x, rhs.x, getMod());
        return *this;
    }
    constexpr MLong &operator+=(MLong rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MLong &operator-=(MLong rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MLong &operator/=(MLong rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MLong operator*(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MLong operator+(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MLong operator-(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MLong operator/(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {
        i64 v;
        is >> v;
        a = MLong(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MLong lhs, MLong rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MLong lhs, MLong rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
i64 MLong<0LL>::Mod = i64(1E18) + 9;
 
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998244353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 998244353;
using Z = MInt<P>;





// Comb
using LL = long long;
template <class T>
constexpr T power(T a, LL b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr LL mul(LL a, LL b, LL p) {
    LL res = a * b - LL(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template <LL P>
struct MLong {
    LL x;
    constexpr MLong() : x{} {}
    constexpr MLong(LL x) : x{norm(x % getMod())} {}

    static LL Mod;
    constexpr static LL getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(LL Mod_) { Mod = Mod_; }
    constexpr LL norm(LL x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr LL val() const { return x; }
    explicit constexpr operator LL() const { return x; }
    constexpr MLong operator-() const {
        MLong res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MLong inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MLong& operator*=(MLong rhs) & {
        x = mul(x, rhs.x, getMod());
        return *this;
    }
    constexpr MLong& operator+=(MLong rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MLong& operator-=(MLong rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MLong& operator/=(MLong rhs) & { return *this *= rhs.inv(); }
    friend constexpr MLong operator*(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MLong operator+(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MLong operator-(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MLong operator/(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream& operator>>(std::istream& is, MLong& a) {
        LL v;
        is >> v;
        a = MLong(v);
        return is;
    }
    friend constexpr std::ostream& operator<<(std::ostream& os, const MLong& a) { return os << a.val(); }
    friend constexpr bool operator==(MLong lhs, MLong rhs) { return lhs.val() == rhs.val(); }
    friend constexpr bool operator!=(MLong lhs, MLong rhs) { return lhs.val() != rhs.val(); }
};

template <>
LL MLong<0LL>::Mod = LL(1E18) + 9;

template <int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(LL x) : x{norm(x % getMod())} {}

    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) { Mod = Mod_; }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const { return x; }
    explicit constexpr operator int() const { return x; }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt& operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt& operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt& operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt& operator/=(MInt rhs) & { return *this *= rhs.inv(); }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream& operator>>(std::istream& is, MInt& a) {
        LL v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream& operator<<(std::ostream& os, const MInt& a) { return os << a.val(); }
    friend constexpr bool operator==(MInt lhs, MInt rhs) { return lhs.val() == rhs.val(); }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) { return lhs.val() != rhs.val(); }
};

template <>
int MInt<0>::Mod = 1000000007;
// int MInt<0>::Mod = 998244353;
template <int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();

// constexpr int P = 998244353;
constexpr int P = 1000000007;
using Z = MInt<P>;

struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;

    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() { init(n); }

    void init(int m) {
        m = std::min(m, Z::getMod() - 1);
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);

        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }

    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

int main() {
    // 使用方法
    const int N = 100010;  // 计算组合数的最大N
    Comb A = Comb(N);
    LL a = 100, b = 1;
    // C(a, b)组合数
    Z ans = A.binom(a, b);

    // ans.x就是结果

    // 更好的方法
    Z _ans = comb.binom(a, b);

    std::cout << ans.x << std::endl;
    std::cout << _ans.x << std::endl;
}





// 组合数
namespace Comb {
constexpr LL N = 1e5 + 50;
constexpr LL MOD = 1e9 + 7;
LL frac[N];  // 阶乘

void init() {
    frac[0] = frac[1] = 1;
    for (LL i = 2; i < N; ++i) frac[i] = frac[i - 1] * i % MOD;
}

LL fpow(LL x, LL exp) {  // 快速幂
    LL res = 1;
    for (; exp; exp /= 2) {
        if (exp & 1) res = res * x % MOD;
        x = x * x % MOD;
    }
    return res;
}

/* C(n, k) means select k from n. */
LL C(LL n, LL k) {
    LL upper = frac[n];
    LL lower = (fpow(frac[k], MOD - 2) * fpow(frac[n - k], MOD - 2)) % MOD;  // 逆元

    return (upper * lower) % MOD;
}
};  // namespace Comb
using namespace Comb;
int main() {
    // 使用举例
    init();
    std::cout << C(4, 2) << std::endl;
}





// 埃氏筛
// 质数筛
void solve() {
    const int N = 1e5 + 1;
    bool isPrime[N];
    memset(isPrime, true, sizeof(isPrime));
    isPrime[1] = false;
    isPrime[0] = false;
    // 埃氏筛
    for (int i = 2; i * i < N; ++i) {
        if (isPrime[i]) {  // 如果是质数, 就从i * i 开始把i的倍数标记为合数
            for (int j = i * i; j < N; j += i) {
                isPrime[j] = false;
            }
        }
    }
}





// 预处理回文数字
vector<LL> A;
int init = []() {  // 预处理1e9内的所有回文数字, 这种写法, 可以保证只执行一次
    for (LL i = 1; i <= 100000; i++) {
        // 第一部分 12345->123454321
        LL p = i;
        for (LL x = i / 10; x > 0; x /= 10) {
            p = p * 10 + x % 10;
        }
        if (p < 1e9) A.push_back(p);
        // 第二部分 12345->1234554321
        p = i;
        for (LL x = i; x > 0; x /= 10) {
            p = p * 10 + x % 10;
        }
        if (p < 1e9) A.push_back(p);
    }
    sort(A.begin(), A.end());
    return 0;
}();

// 1e11内的所有回文数字
namespace EE11 {
using LL = long long;
vector<LL> A;
int init = []() {  // 预处理1e13内的所有回文数字, 这种写法, 可以保证只执行一次
    // 高效枚举1e11内的回文数
    for (LL i = 1; i <= 1000000; i++) {
        // 第一部分 12345->123454321
        LL p = i;
        for (LL x = i / 10; x > 0; x /= 10) {
            p = p * 10 + x % 10;
        }
        if (p < 1e11) A.push_back(p);
        // 第二部分 12345->1234554321
        p = i;
        for (LL x = i; x > 0; x /= 10) {
            p = p * 10 + x % 10;
        }
        if (p < 1e11) A.push_back(p);
    }
    sort(A.begin(), A.end());
    return 0;
}();
};  // namespace EE11

// 1e13内的所有回文数
namespace EE13 {
using LL = long long;
vector<LL> A;
int init = []() {  // 预处理1e13内的所有回文数字, 这种写法, 可以保证只执行一次
    for (LL i = 1; i <= 10000000; i++) {
        // 第一部分 12345->123454321
        LL p = i;
        for (LL x = i / 10; x > 0; x /= 10) {
            p = p * 10 + x % 10;
        }
        if (p < 1e13) A.push_back(p);
        // 第二部分 12345->1234554321
        p = i;
        for (LL x = i; x > 0; x /= 10) {
            p = p * 10 + x % 10;
        }
        if (p < 1e13) A.push_back(p);
    }
    sort(A.begin(), A.end());
    return 0;
}();
};  // namespace EE13




// 二维前缀和
class Solution {
   public:
    void f(vector<vector<int>>& g) {
        // 预处理二维前缀和
        int m = g.size(), n = g[0].size();
        vector s(m + 1, vector<int>(n + 1, 0));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + (g[i][j]);
            }
        }
        // 返回[1, 2)的区域和, 左闭右开
        auto query = [&](int r1, int c1, int r2, int c2) -> int { return s[r2][c2] - s[r2][c1] - s[r1][c2] + s[r1][c1]; };
    }
};




// Trie
template<char MIN_CHAR = 'a', int ALPHABET = 26>
struct array_trie {
    struct trie_node {
        array<int, ALPHABET> child;
        int words_here = 0, starting_with = 0;

        trie_node() {
            memset(&child[0], -1, ALPHABET * sizeof(int));
        }
    };

    static const int ROOT = 0;

    vector<trie_node> nodes = {trie_node()};

    array_trie(int total_length = -1) {
        if (total_length >= 0)
            nodes.reserve(total_length + 1);
    }

    int get_or_create_child(int node, int c) {
        if (nodes[node].child[c] < 0) {
            nodes[node].child[c] = int(nodes.size());
            nodes.emplace_back();
        }

        return nodes[node].child[c];
    }

    int build(const string &word, int delta) {
        int node = ROOT;

        for (char ch : word) {
            nodes[node].starting_with += delta;
            node = get_or_create_child(node, ch - MIN_CHAR);
        }

        nodes[node].starting_with += delta;
        return node;
    }

    int add(const string &word) {
        int node = build(word, +1);
        nodes[node].words_here++;
        return node;
    }

    int erase(const string &word) {
        int node = build(word, -1);
        nodes[node].words_here--;
        return node;
    }

    int find(const string &str) const {
        int node = ROOT;

        for (char ch : str) {
            node = nodes[node].child[ch - MIN_CHAR];

            if (node < 0)
                break;
        }

        return node;
    }

    // Given a string, how many words in the trie are prefixes of the string?
    int count_prefixes(const string &str, bool include_full) const {
        int node = ROOT, count = 0;

        for (char ch : str) {
            count += nodes[node].words_here;
            node = nodes[node].child[ch - MIN_CHAR];

            if (node < 0)
                break;
        }

        if (include_full && node >= 0)
            count += nodes[node].words_here;

        return count;
    }

    // Given a string, how many words in the trie start with the given string?
    int count_starting_with(const string &str, bool include_full) const {
        int node = find(str);

        if (node < 0)
            return 0;

        return nodes[node].starting_with - (include_full ? 0 : nodes[node].words_here);
    }
};



// 01trie
template <class T = int>
struct xortrie {
    vector<array<int, 2>> trie = {{0, 0}};
    vector<int> cnt = {0};
    int NUM_BITS = 31;

    xortrie() {}

    xortrie(int bits, int elements = -1) {
        NUM_BITS = bits;
        if (elements != -1) {
            trie.reserve(elements * bits);
            cnt.reserve(elements * bits);
        }
    }
    
    void update(T val, int delta) {
        int node = 0;
        for (int i = NUM_BITS - 1; i >= 0; i--) {
            int c = val & (1ll << i) ? 1 : 0;
            if (!trie[node][c]) {
                trie[node][c] = trie.size();
                trie.push_back({0, 0});
                cnt.push_back(0);
            }
            node = trie[node][c];
            cnt[node] += delta;
        }
    }

    void insert(T val) { update(val, 1); }

    void erase(T val) { update(val, -1); }

    T max(T val) {
        // Find max of val XOR element
        T res = 0;
        int node = 0;
        for (int i = NUM_BITS - 1; i >= 0; i--) {
            int c = val & (1ll << i) ? 0 : 1;
            if (trie[node][c] && cnt[trie[node][c]]) {
                res ^= 1ll << i;
                node = trie[node][c];
            } else
                node = trie[node][c ^ 1];
        }
        return res;
    }

    T min(T val) {
        // Find min of val XOR element
        T res = 0;
        int node = 0;
        for (int i = NUM_BITS - 1; i >= 0; i--) {
            int c = val & (1ll << i) ? 1 : 0;
            if (trie[node][c] && cnt[trie[node][c]])
                node = trie[node][c];
            else {
                res ^= 1ll << i;
                node = trie[node][c ^ 1];
            }
        }
        return res;
    }

    int less_than(T val, T limit) {
        // How many elements satisfy val XOR element < limit ?
        int res = 0, node = 0;
        for (int i = NUM_BITS - 1; i >= 0; i--) {
            int c = val & (1ll << i) ? 1 : 0;
            if (limit & (1ll << i)) {
                res += cnt[trie[node][c]];
                if (trie[node][c ^ 1] && cnt[trie[node][c ^ 1]])
                    node = trie[node][c ^ 1];
                else
                    break;
            } else {
                if (trie[node][c] && cnt[trie[node][c]])
                    node = trie[node][c];
                else
                    break;
            }
        }
        return res;
    }
};



// Dijkstra
class Solution {
   public:
    LL N;                   // N个点, 编号是0~N-1
    vector<LL> dis;         // 最短路径
    vector<LL> vis;         // visit数组
    vector<vector<PLL>> g;  // 建图, g[u]存(v, w)
    void dijkstra(LL start) {
        priority_queue<PLL, vector<PLL>, greater<PLL>> pq;  // 小顶堆
        pq.push(PLL(0, start));
        dis[start] = 0;
        while (pq.size()) {
            auto [d, u] = pq.top();
            pq.pop();
            if (vis[u]) continue;
            vis[u] = 1;
            for (auto& [v, cost] : g[u]) {
                if (dis[v] > d + cost) {
                    dis[v] = d + cost;
                    pq.push(PLL(dis[v], v));
                }
            }
        }
    }
    void init(int n, vector<vector<int>>& roads) {  // Dijkstra
        // 初始化变量们, 并建图
        N = n;
        dis = vector<LL>(N, 1e18);
        vis = vector<LL>(N, 0);
        g = vector<vector<PLL>>(N);
        for (auto& r : roads) {
            int u = r[0], v = r[1], w = r[2];
            g[u].push_back(PLL(v, w));
            g[v].push_back(PLL(u, w));
        }
        // 计算所有点到start的距离
        dijkstra(0);
    }
};











static constexpr long long mod = 998244353;
// static constexpr long long mod = 1000000007;

void solve() {}

signed main() {
    std::ios::sync_with_stdio(0), std::cout.tie(0), std::cin.tie(0);
    int T = 1;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}